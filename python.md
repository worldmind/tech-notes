Когда-то давно, в студенческие годы, меня укусил питон, правда инкубационный период затянулся и получилось так, что я стал программистом на перле.

Однако в какой-то момент перл исчерпал себя и я решил заняться питоном, сначала просто делал что-то и разбирался с тем, что нужно для данной задачи, а потом понял, что нужны какие-то систематизированные знания и прочитал несколько книг:

* Билл Любанович «Простой Python. Современный стиль программирования»
* Дэн Бейдер «Чистый Python. Тонкости программирования для профи»
* Бретт Слаткин «Секреты Python: 59 рекомендаций по написанию эффективного кода»

Которые мне показались вполне подходящими для понимания основных тонкостей языка, хотя не помню, чтобы в них упоминалось про [__slots__](http://www.attrs.org/en/stable/glossary.html), но и не уверен, что это реально нужная фича - если уже по памяти прижало, то скорее всего одного этого способа будет недостаточно, но конечно это всё зависит от ситуации.

В итоге у меня накопились какие-то заметки об особенностях питона, которые, как мне кажется, могут быть полезны тому кто пожелает мигрировать на него с других языков.
<cut />
Я заметил, что на собеседованиях по питону достаточно часто задают вопросы про вещи не имеющие отношения к реальной разработке, типа того, что может быть ключом словаря (или про то что означает `x = yield y`), ну чуваки, в реальной жизни ключом может быть только число или строка, в тех уникальных случаях когда это не так, можно почитать документацию и разобраться, зачем спрашивать такое? Чтобы найти чего собеседуемый не знает? Так в итоге все запомнят ответ именно на этот вопрос и это перестанет работать.

Актуальными я считаю питон версий выше 3.5 (про второй питон давно [пора забыть](https://habr.com/company/otus/blog/425233/)) т.к. именно такая версия в стабильном дебиане, а значит во всех остальных местах более свежие версии )

Так как я вовсе не гуру питона, то надеюсь меня поправят в комментариях если я вдруг сморозил какую-то глупость.

## Типизация

Питон динамически типизированный язык т.е. он проверяет соответствие типов в процессе выполнения, например:

    cat type.py

    a=5
    b='5'
    print(a+b)

выполняем:

    python3 type.py
    ... TypeError: unsupported operand type(s) for +: 'int' and 'str'

Однако, если ваш проект дозрел до необходимости статической типизации, то питон предоставляет и такую возможность путём использования статического анализатора `mypy`:

    mypy type.py
    type.py:3: error: Unsupported operand types for + ("int" and "str")

Правда так ловятся не все ошибки:

    cat type2.py

    def greeting(name):
        return 'Hello ' + name

    greeting(5)

mypy тут не ругнётся, а при выполнении случится ошибка, поэтому актуальные версии питона поддерживают специальный синтаксис для указания типов аргументов функций:

    cat type3.py
    def greeting(name: str) -> str:
        return 'Hello ' + name

    greeting(5)

а теперь:

    mypy type3.py
    type3.py:4: error: Argument 1 to "greeting" has incompatible type "int"; expected "str"

## Переменные и данные

Переменные в питоне не хранят данные, а лишь ссылаются на них, а данные бывают изменяемые (мутабельные) и неизменяемые (иммутабельные).
Это приводит к различному поведению в зависимости от типа данных в практически идентичных ситуациях, например такой код:

    x = 1
    y = x
    x = 2
    print(y)

приводит к тому, что переменные `x` и `y` ссылаются на различные данные, а такой:

    x = [1, 2, 3]
    y = x
    x[0] = 7
    print(y)

нет, `x` и `y` остаются ссылками на один и тот же список (хотя как [заметили в комментариях](https://habr.com/post/426277/#comment_19231481) пример не очень удачный, но лучше я пока не придумал), что кстати в питоне можно проверить оператором `is` (я уверен что создатель джавы навсегда лишился хорошего сна от стыда когда узнал про этот оператор в питоне).

Строки хотя и похожи на список являются иммутабельным типом данных, это значит, что саму строку изменить нельзя, можно лишь породить новую, но переменной можно присвоить другое значение, хотя исходные данные при этом не изменятся:

    >>> mystr = 'sss'
    >>> newstr = mystr  # делаем ссылку на те же данные
    >>> mystr[0] = 'a'
    ...
      TypeError: 'str' object does not support item assignment
    >>> mystr = 'ssa'  # меняем исходную переменную
    >>> newstr  # данные не изменились и доступны по второй ссылке
      'sss'

Кстати, о строках, из-за их иммутабельности конкатенация очень большого списка строк сложением или append'ом в цикле может быть не очень эффективной (зависит от рализации в конкретном компиляторе/версии), обычно для таких случаев рекомендуют использовать метод [join](https://docs.python.org/3/library/stdtypes.html#str.join), который ведёт себя немного неожиданно:

    >>> str_list = ['ss', 'dd', 'gg']
    >>> 'XXX'.join(str_list)
    'ssXXXddXXXgg'
    >>> str = 'hello'
    >>> 'XXX'.join(str)
    'hXXXeXXXlXXXlXXXo'

Во-первых, строка у которой вызывается метод становиться разделителем, а не началом новой строки как можно было бы подумать, а во-вторых, передавать нужно список (итерируемый объект), а не отдельную строку ибо таковая тоже является итерируемым объектом и будет сджойнена посимвольно.

Так как переменные это ссылки, то вполне нормальным является желание сделать копию объекта, чтобы не ломать исходный объект, однако тут есть подводный камень - функция [copy](https://docs.python.org/3/library/copy.html) копирует только один уровень, что явно не то, что ожидается от функции с таким именем, поэтому используете `deepcopy`.

Аналогичная проблема с копированием может возникать при умножении коллекции на скаляр, как разбиралось [тут](https://habr.com/post/422951/).

## Область видимости

Тема области видимости скорее заслуживает отдельной статьи, но есть [хороший ответ на SO](https://stackoverflow.com/a/23471004/8583496).
Если кратко, то область видимости [лексическая](https://stackoverflow.com/a/1047491/8583496) и есть шесть областей видимости - переменные в теле функции, в замыкании, в модуле, в теле класса, встроенные в питон фунции и переменные внутри списковых и иных включений.
Есть тонкость - переменная по умолчанию доступна для чтения в лексически вложенных пространствах имён, но модификация требует использования специальных ключевых слов `nonlocal` и `global` для модификации переменных на один уровень выше или глобальной видимости соответственно.

Например, такой код:

    x = 7
    print(id(x))

    def func():
        print(id(x))
        return x

    print(func())

Работает с одной глобальной переменной, а такой:

    x = 7
    print(id(x))

    def func():
        x = 1
        print(id(x))
        return x

    print(func())
    print(x)

уже порождает локальную.
С моей точки зрения это не очень хорошо, по идее любое использование нелокальных переменных в функции это часть публичного интерфейса функции, её сигнатуры, а значит должно объявляться явно и видимо в начале функции. Также ключевые слова не очень информативны - `global` звучит как определение глобальной функции, а на самом деле означает `use global`.

В питоне нет обязательной точки входа с которой начинается выполнение программы как это сделано во многих языках, просто всё что написано на уровне модуля последовательно выполняется, однако так как переменные на уровне модуля это глобальные переменные, то, с моей точки зрения, хорошей практикой должно быть запихивание основного кода в функцию `main()` с последующим её вызовом в конце файла:

    if __name__ == '__main__':
        main()

такое условие сработает если файл будет вызван как скрипт, а не импортирован как модуль.

## Аргументы функций

Питон предоставляет просто шикарные возможности за заданию аргументов функций - позиционные, именованные аргументы и их комбинации.

Но нужно понимать как осуществляется передача аргументов - т.к. в питоне все переменные это ссылки на данные, то можно догадаться, что передача осуществляется по ссылке, однако тут есть особенность - сама ссылка передаётся по значению т.е. вы можете модифицировать мутабельное значение по ссылке:

    def add_element(mylist):
        mylist.append(3)

    mylist = [1,2]
    add_element(mylist)
    print(mylist)

выполняем:

    python3 arg_modify.py
    [1, 2, 3]

однако нельзя затереть исходную ссылку в функции:

    def try_del(mylist):
        mylist = []
        return mylist

    mylist = [1,2]
    try_del(mylist)
    print(mylist)

исходная ссылка жива и работает:

    python3 arg_kill.py
    [1, 2]

Также для аргументов можно задавать значения по умолчанию, но с этим есть одна неочевидная вещь которую нужно запомнить - значения по умолчанию вычисляются один раз при определении функции, это не создаёт никаких проблем, если вы в качестве значения по умолчанию передаёте неизменяемые данные, а если передаются изменяемые данные или динамическое значение, то результат будем чуток неожиданным:

изменяемые данные:

    cat arg_list.py

    def func(arg = []):
        arg.append('x')
        return arg

    print(func())
    print(func())
    print(func())

результат:

    python3 arg_list.py
    ['x']
    ['x', 'x']
    ['x', 'x', 'x']

динамическое значение:

    cat arg_now.py

    from datetime import datetime

    def func(arg = datetime.now()):
        return arg

    print(func())
    print(func())
    print(func())

получаем:

    python3 arg_now.py
    2018-09-28 10:28:40.771879
    2018-09-28 10:28:40.771879
    2018-09-28 10:28:40.771879

## ООП

ООП в питоне сделано весьма интересно (одни `property` чего стоят) и это большая тема, однако сапиенс знакомый с ООП вполне может нагуглить всё (или найти на [хабре](https://habr.com/ru/post/455796/)), что ему захочется, поэтому нет смысла повторяться, хотя стоит оговорить, что питон следует немного другой философии - считается, что программист умнее машины и не является вредителем (UPD: [подробнее](https://habr.com/ru/post/457034/)), поэтому в питоне по умолчанию нет привычных по другим языкам модификаторов доступа: private методы реализуются добавлением двойного подчёркивания (что в рантайме изменяет имя метода не позволяя случайно его использовать), а protected одним подчёркиванием (что не делает ничего, это просто соглашение об именовании).
Те кто скучает по привычному функционалу могут поискать попытки привнести в питон такие возможности, мне нагуглилась пара вариантов ([lang](https://github.com/amitassaraf/lang), [python-access](https://github.com/igor-shevchenko/python-access)), но я их не тестировал и не изучал.

Единственный минус стандартных классов - шаблонный код во всяких [дандер методах](https://dbader.org/blog/python-dunder-methods), лично мне нравится библиотека [attrs](https://pypi.org/project/attrs/), она значительно более питоническая.
Стоит упомянуть, что так в питоне всё объекты, включая функции и классы, то классы можно создавать динамически (без использования `eval`) функцией [type](https://docs.python.org/3/library/functions.html?highlight=type#type).
Также стоит почитать про [метаклассы](https://docs.python.org/3/reference/datamodel.html#metaclasses) ([на хабре](https://habr.com/post/145835/)) и [дескрипторы](https://docs.python.org/3/howto/descriptor.html) ([хабр](https://habr.com/post/122082/)).
Особенность, которую стоит запомнить - атрибуты класса и объекта это не одно и тоже, в случае неизменяемых атрибутов это не вызывает проблем так как атрибуты "затеняются" (shadowing) - создаются автоматически атрибуты объекта с таким же именем, а вот в случае изменяемых атрибутов можно получить не совсем то, что ожидалось:

    cat class_attr.py
    class MyClass:
        storage = [7,]
        def __init__(self, number):
            self.number = number

    obj = MyClass(1)
    obj2 = MyClass(2)

    obj.number = 5
    obj.storage.append(8)

    print(obj2.storage, obj2.number)

получаем:

    python3 class_attr.py
    [7, 8] 2

как можно увидеть - изменяли `obj`, а `storage` изменился и в `obj2` т.к. этот атрибут (в отличии от `number`) принадлежит не экземпляру, а классу.

## Константы

Как и в случае с модификаторами доступа питон не пытается ограничить разработчика, поэтому задачать скалярную переменную защищённую от модификации стандартным способом нельзя, просто есть соглашение, что переменные с именем в верхнем регистре нужно считать константами.
С другой стороны в питоне есть неизменяемые структуры данных такие как tuple, поэтому если вы хотите сделать неизменяемой какую-то глобальную структуру вроде конфига и не хотите дополнительных зависимостей, то [namedtuple](https://habr.com/ru/post/330034/), вполне хороший выбор, хотя он потребует немного больше усилий для описания типов, поэтому мне нравится альтернативная реализация неизменяемой структуры с dot-notation - [Box](https://github.com/cdgriffith/Box) (см. параметр frozen_box).
Ну а если вам хочется скалярных констант, то можно реализовать проверку доступа к ним на стадии "компиляции" т.е. проверки через mypy, [пример](https://dev.to/wemake-services/1-minute-guide-to-real-constants-in-python-2bpk) и [подробности](https://mypy.readthedocs.io/en/latest/final_attrs.html).

## .sort() vs sorted()

В питоне есть два способо сортировать список. Первый это метод `.sort()` который изменяет исходный список и ничего не возвращает (None) т.е. не получится сделать так:

    my_list = my_list.sort()

Второй, это функция `sorted()` которая порождает новый список и умеет работать со всеми итерируемыми объектами. Кому хочется больше инфы стоит начать с [SO](https://stackoverflow.com/a/22442440/8583496).

## Стандартная библиотека

Обычно стандартная библиотека питона включает отличные решения типовых проблем, однако стоит подходить критически, ибо хватает и странностей. Правда бывает и так, что то, что на первый взгляд кажется странным, в итоге оказывается наилучшим решением, просто нужно знать все условия (см. далее про range), но всё же есть и странности.

Например, идущий в комплекте модуль для модульного тестирования [unittest](https://docs.python.org/3/library/unittest.html) не имеет никакого отношения к питону и попахивает джавой, поэтому, как [говорит автор питона](https://bugs.python.org/issue17908#msg242166): "Eveybody is using py.test ...". Хотя вполне интересный, пусть и не всегда подходящий модуль [doctest](https://docs.python.org/3.7/library/doctest.html) идёт в стандартной поставке.

Идущий в поставке модуль [urllib](https://docs.python.org/3/library/urllib.html) не имеет такого прекрасного интерфейса как стронний модуль [requests](https://github.com/kennethreitz/requests).

Та же история с модулем для разбора параметров коммандной строки - идущий в комплекте [argparse](https://docs.python.org/3/library/argparse.html) это демонстрация ООП головного мозга, а модуль [docopt](https://github.com/docopt/docopt) кажется просто шикарным решением - предельная самодокументируемость! Хотя, по слухам, несмотря на docopt и для [click](https://pypi.org/project/click/) остаётся ниша.

С отладчиком также - как я понял идущий в комплекте [pdb](https://docs.python.org/3/library/pdb.html) мало кто использует, альтернатив много, но похоже основная масса разработчиков используется [ipdb](https://pypi.org/project/ipdb/), который, с моей точки зрения удобнее всего использовать через модуль-обёртку [debug](https://github.com/narfdotpl/debug).
Она позволяет вместо `import ipdb;ipdb.set_trace()` просто написать `import debug`, также она добавляет модуль [see](https://pypi.org/project/see/) для удобной инспекции объектов.

На замену стандартному модулю сериализации [pickle](https://docs.python.org/3/library/pickle.html) делают [dill](https://pypi.org/project/dill/), тут кстати стоит запомнить, что эти модули не подходят для обмена данными в внешними системами т.к. восстанавливать произвольные объекты полученные из неконтролируемого источника небезопасно, для таких случаев есть json (для REST) и [gRPC](https://github.com/grpc/grpc) (для RPC).

На замену стандартному модулю обработкти регулярных выражений [re](https://docs.python.org/3/library/re.html) делают модуль [regex](https://pypi.org/project/regex/) со всякими дополнительными плюшками, вроде классов символов аля `\p{Cyrillic}`.
Кстати, что-то не попалось для питона весёлого отладчика для регексов похожего на [перловый](https://www.learning-perl.com/2016/06/watch-regexes-with-regexpdebugger/).

Вот другой пример - человек сделал свой модуль [in-place](https://pypi.org/project/in-place/), чтобы пофиксить кривизну и неполноту API стандартного модуля [fileinput](https://docs.python.org/3/library/fileinput.html) в части in place редактирования файлов.

Ну и таких случаев думаю много, раз даже мне попался не один, так что будьте бдительны и не забывайте заглядывать во всякие списки полезняшек типа [awesome](https://github.com/vinta/awesome-python), я думаю, что у хорошего питонщика есть чуйка на меру питоничности решения, это кстати тема для отдельного разговора - по моим ощущениям (конечно статистики никакой на эту тему нет и видимо не может быть) в питон-мире уровень специалистов выше среднего, ибо часто хорошие софтины оказываются написанными на питоне, напишите в комментариях, что вы думаете по этому поводу.

## Параллелизм и конкурентность

Питон предоставляет широкие возможности как для параллельного, так и для конкурентного программирования, однако не обходиться без особенностей.

Если вам нужен параллелизм, а это бывает когда ваши задачи требуют вычислений, то вам стоит обратить внимание на модуль [multiprocessing](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.pool.multiprocessing.Pool.map).

А если в ваших задачах много ожидания IO, то питон предоставляет массу вариантов на выбор, от тредов и [gevent](http://www.gevent.org/), до [asyncio](https://docs.python.org/3/library/asyncio.html).
Все эти варианты выглядят вполне пригодными для использования (хотя треды значительно больше ресурсов требуют), но есть ощущение, что asyncio потихоньку выдавливает остальных, в том числе благодаря всяким плюшками типа [uvloop](https://github.com/MagicStack/uvloop).

Если кто не заметил - в питоне треды это не про параллельность, я недостаточно компетентен, чтобы хорошо рассказать про [GIL](https://wiki.python.org/moin/GlobalInterpreterLock), но по это теме достаточно материалов, поэтому и нет такой необходимости, главное, что нужно запомнить это то, что треды в питоне (точнее в CPython) ведут себя не так как это принято в других языках программирования - они исполняются только на одном ядре, а значит не подходят для случаев когда вам нужна настоящая параллельность, однако, выполнение тредов приостанавливается при ожидании ввода-вывода, поэтому их можно использовать для конкурентности.

## Иные странности

В питоне `a = a + b` не всегда эквивалентно `a += b`:

    a = [1]
    a = a + (2,3)
    TypeError: can only concatenate list (not "tuple") to list
    a += (2,3)
    a
    [1, 2, 3]

За деталями отправляю на [SO](https://stackoverflow.com/questions/6951792/python-a-b-not-the-same-as-a-a-b) ибо пока не нашёл времени разобраться почему оно так, в смысле по каким причинам так сделали, вроде это опять про мутабельность.

## Странности, которые не странности

На первый взгляд мне показалось странным, что тип range не включает правую границу, но потом добрый человек [подсказал](https://habr.com/post/319200/#comment_10066152) мне неучу где [мне нужно поучиться](https://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html) и оказалось, что всё вполне логично.

Отдельная большая тема это округления (хотя это проблема общая практически для всех языков программирования), помимо того, что округление используется какое угодно кроме того, что все изучали в школьном курсе математики, так на это ещё накладываются проблемы преставления чисел с плавющей точкой, отсылаю к подробной [статье](https://realpython.com/python-rounding/).
Грубо говоря вместо привычного, по школьному курсу математики, округления по алгоритма [half up](https://en.wikipedia.org/wiki/Rounding#Round_half_up) используется алгоритм [half to even](https://en.wikipedia.org/wiki/Rounding#Round_half_to_even), которые уменьшает вероятность искажений при статистическом анализе и поэтому рекомендуется стандартом IEEE 754.

Также я не мог понять почему `-22//10=-3`, а потом, другой добрый человек, [указал](https://habr.com/post/422951/#comment_19115923), что это неизбежно следует из самого математического определения, по которому, остаток не может быть отрицательным, что и приводит к такому необычному поведению для отрицательных чисел.
ACHTUNG! Теперь это опять странность и я ничего не понимаю, см. сей [тред](https://habr.com/post/426277/?reply_to=19248649#comment_19248649).

## Отладка регулярных выражений

А вот тут оказалось, что в мире питоне нет инструмента для интерактивной отладки регулярных выражений аналогичного прекрасному перловому модулю [Regexp::Debugger](https://metacpan.org/pod/Regexp::Debugger) ([видеопрезентация](https://youtu.be/zcSFIUiMgAs?t=158)), конечно есть куча онлайн-инструментов, есть какие-то виндовопроприетарные решения, но для меня это всё не то, возможно стоит использовать перловый инструмент, ибо питонные регэксы не особо отличаются от перловых, напишу инструкцию для невладеющих перловым инструментарием:

    sudo apt install cpanminus
    cpanm Regexp::Debugger
    perl -I ~/perl5/lib/perl5/ -E "use Regexp::Debugger; 'ababc' =~ /(a|b) b+ c/x"

Думаю даже человек незнакомый с перлом поймёт где тут надо вписать строку, а где регулярное выражение, `x` это флаг аналогичный питонному re.VERBOSE.
Нажимаем `s` и шагаем по регулярному выражению, подробное описание доступных команд в [документации](https://metacpan.org/pod/Regexp::Debugger).